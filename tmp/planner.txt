use sqlparser::{
    ast::{
        BinaryOperator, Expr, Ident, JoinConstraint, JoinOperator, ObjectName, ObjectNamePart, 
        Query, SelectItem, Statement, TableFactor, TableWithJoins, Value,
    },
    dialect::Dialect,
    parser::Parser,
};
use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone)]
pub enum LogicalPlan {
    TableScan {
        table_name: String,
        alias: Option<String>,
        projected_schema: Vec<String>,
    },
    Projection {
        expressions: Vec<LogicalExpr>,
        input: Box<LogicalPlan>,
    },
    Selection {
        predicate: LogicalExpr,
        input: Box<LogicalPlan>,
    },
    Join {
        left: Box<LogicalPlan>,
        right: Box<LogicalPlan>,
        join_type: JoinType,
        join_constraint: Option<LogicalExpr>,
    },
}

#[derive(Debug, Clone)]
pub enum LogicalExpr {
    Column { name: String, table: Option<String> },
    Literal(ScalarValue),
    BinaryExpr {
        left: Box<LogicalExpr>,
        op: BinaryOperator,
        right: Box<LogicalExpr>,
    },
    Wildcard { table: Option<String> },
}

#[derive(Debug, Clone)]
pub enum ScalarValue {
    Utf8(String),
    Int64(i64),
    Float64(f64),
    Boolean(bool),
    Null,
}

#[derive(Debug, Clone)]
pub enum JoinType {
    Inner,
    Left,
    Right,
    Full,
    Cross,
}

pub struct ExecutionContext {
    pub dialect: Box<dyn Dialect>,
    // Simple catalog to store table schemas (in real implementation, this would be more sophisticated)
    pub catalog: HashMap<String, Vec<String>>,
}

impl ExecutionContext {
    pub fn new(dialect: Box<dyn Dialect>) -> Self {
        let mut catalog = HashMap::new();
        
        // Mock catalog with some sample tables
        catalog.insert("users".to_string(), vec!["id".to_string(), "name".to_string(), "email".to_string()]);
        catalog.insert("orders".to_string(), vec!["id".to_string(), "user_id".to_string(), "amount".to_string()]);
        catalog.insert("products".to_string(), vec!["id".to_string(), "name".to_string(), "price".to_string()]);
        
        Self { dialect, catalog }
    }

    pub fn execute(&self, sql: &str) -> Result<LogicalPlan, String> {
        let ast = Parser::parse_sql(self.dialect.as_ref(), sql)
            .map_err(|e| format!("Parse error: {}", e))?;
        
        if ast.is_empty() {
            return Err("No statements found".to_string());
        }

        let stmt = &ast[0];
        self.create_logical_plan(stmt)
    }

    pub fn explain(&self, sql: &str) -> String {
        match self.execute(sql) {
            Ok(plan) => {
                let mut result = format!("Query: {}\n\n", sql);
                result.push_str("Logical Plan:\n");
                result.push_str(&self.format_plan(&plan, 0));
                result.push_str(&format!("\nEstimated Cost: {}\n", self.estimate_cost(&plan)));
                result
            }
            Err(e) => format!("Error: {}", e),
        }
    }

    fn create_logical_plan(&self, stmt: &Statement) -> Result<LogicalPlan, String> {
        match stmt {
            Statement::Query(query) => self.plan_query(query.as_ref()),
            _ => Err("Only SELECT queries are supported".to_string()),
        }
    }

    fn plan_query(&self, query: &Query) -> Result<LogicalPlan, String> {
        let select = match &*query.body {
            sqlparser::ast::SetExpr::Select(select) => select,
            sqlparser::ast::SetExpr::Query(_) => {
                return Err("Nested queries are not supported yet".to_string());
            }
            sqlparser::ast::SetExpr::SetOperation { .. } => {
                return Err("Set operations (UNION, INTERSECT, EXCEPT) are not supported yet".to_string());
            }
            sqlparser::ast::SetExpr::Values(_) => {
                return Err("VALUES clauses are not supported yet".to_string());
            }
            sqlparser::ast::SetExpr::Insert(_) => {
                return Err("INSERT statements in query context not supported".to_string());
            }
            sqlparser::ast::SetExpr::Update(_) => {
                return Err("UPDATE statements in query context not supported".to_string());
            }
            sqlparser::ast::SetExpr::Table(_) => {
                return Err("TABLE expressions are not supported yet".to_string());
            }
        };

        // Step 1: Handle FROM clause (table scans and joins)
        let mut plan = self.plan_from_clause(&select.from)?;

        // Step 2: Handle WHERE clause (selection/filtering)
        if let Some(ref selection) = select.selection {
            let predicate = self.expr_to_logical_expr(selection)?;
            plan = LogicalPlan::Selection {
                predicate,
                input: Box::new(plan),
            };
        }

        // Step 3: Handle SELECT clause (projection)
        let projection_exprs = self.plan_projection(&select.projection)?;
        plan = LogicalPlan::Projection {
            expressions: projection_exprs,
            input: Box::new(plan),
        };

        Ok(plan)
    }

    fn plan_from_clause(&self, from: &[TableWithJoins]) -> Result<LogicalPlan, String> {
        if from.is_empty() {
            return Err("FROM clause is required".to_string());
        }

        let mut plan = self.plan_table_factor(&from[0].relation)?;

        // Handle joins
        for join in &from[0].joins {
            let right_plan = self.plan_table_factor(&join.relation)?;
            let join_type = self.convert_join_operator(&join.join_operator);
            let join_constraint = match &join.join_operator {
                JoinOperator::Inner(constraint) | 
                JoinOperator::LeftOuter(constraint) | 
                JoinOperator::RightOuter(constraint) | 
                JoinOperator::FullOuter(constraint) => {
                    match constraint {
                        JoinConstraint::On(expr) => Some(self.expr_to_logical_expr(expr)?),
                        JoinConstraint::Using(_) => None, // Simplified for now
                        JoinConstraint::Natural => None,
                        JoinConstraint::None => None,
                    }
                }
                JoinOperator::CrossJoin => None,
                _ => None,
            };

            plan = LogicalPlan::Join {
                left: Box::new(plan),
                right: Box::new(right_plan),
                join_type,
                join_constraint,
            };
        }

        Ok(plan)
    }

    fn plan_table_factor(&self, table_factor: &TableFactor) -> Result<LogicalPlan, String> {
        match table_factor {
            TableFactor::Table { name, alias, .. } => {
                let table_name = self.extract_table_name(name)?;
                let alias_name = alias.as_ref().map(|a| a.name.value.clone());
                
                // Get schema from catalog
                let schema = self.catalog.get(&table_name)
                    .cloned()
                    .unwrap_or_else(|| vec!["*".to_string()]); // Fallback for unknown tables

                Ok(LogicalPlan::TableScan {
                    table_name,
                    alias: alias_name,
                    projected_schema: schema,
                })
            }
            _ => Err("Only table scans are supported in FROM clause".to_string()),
        }
    }

    fn plan_projection(&self, projection: &[SelectItem]) -> Result<Vec<LogicalExpr>, String> {
        let mut expressions = Vec::new();

        for item in projection {
            match item {
                SelectItem::UnnamedExpr(expr) => {
                    expressions.push(self.expr_to_logical_expr(expr)?);
                }
                SelectItem::Wildcard(qualifier) => {
                    let table = qualifier.as_ref().map(|q| self.extract_table_name(q)).transpose()?;
                    expressions.push(LogicalExpr::Wildcard { table });
                }
                SelectItem::ExprWithAlias { expr, alias } => {
                    // For now, treat as unnamed expr (alias handling can be added later)
                    expressions.push(self.expr_to_logical_expr(expr)?);
                }
                _ => return Err("Unsupported SELECT item".to_string()),
            }
        }

        Ok(expressions)
    }

    fn expr_to_logical_expr(&self, expr: &Expr) -> Result<LogicalExpr, String> {
        match expr {
            Expr::Identifier(ident) => {
                Ok(LogicalExpr::Column {
                    name: ident.value.clone(),
                    table: None,
                })
            }
            Expr::CompoundIdentifier(parts) => {
                if parts.len() == 2 {
                    Ok(LogicalExpr::Column {
                        name: parts[1].value.clone(),
                        table: Some(parts[0].value.clone()),
                    })
                } else {
                    Err("Complex compound identifiers not supported".to_string())
                }
            }
            Expr::Value(value) => {
                let scalar_value = match value {
                    Value::SingleQuotedString(s) => ScalarValue::Utf8(s.clone()),
                    Value::Number(n, _) => {
                        if n.contains('.') {
                            ScalarValue::Float64(n.parse().map_err(|_| "Invalid float")?)
                        } else {
                            ScalarValue::Int64(n.parse().map_err(|_| "Invalid integer")?)
                        }
                    }
                    Value::Boolean(b) => ScalarValue::Boolean(*b),
                    Value::Null => ScalarValue::Null,
                    _ => return Err("Unsupported literal value".to_string()),
                };
                Ok(LogicalExpr::Literal(scalar_value))
            }
            Expr::BinaryOp { left, op, right } => {
                Ok(LogicalExpr::BinaryExpr {
                    left: Box::new(self.expr_to_logical_expr(left)?),
                    op: op.clone(),
                    right: Box::new(self.expr_to_logical_expr(right)?),
                })
            }
            Expr::Wildcard => {
                Ok(LogicalExpr::Wildcard { table: None })
            }
            _ => Err(format!("Unsupported expression: {:?}", expr)),
        }
    }

    fn extract_table_name(&self, name: &ObjectName) -> Result<String, String> {
        if let Some(ObjectNamePart::Identifier(ident)) = name.0.first() {
            Ok(ident.value.clone())
        } else {
            Err("Invalid table name".to_string())
        }
    }

    fn convert_join_operator(&self, join_op: &JoinOperator) -> JoinType {
        match join_op {
            JoinOperator::Inner(_) => JoinType::Inner,
            JoinOperator::LeftOuter(_) => JoinType::Left,
            JoinOperator::RightOuter(_) => JoinType::Right,
            JoinOperator::FullOuter(_) => JoinType::Full,
            JoinOperator::CrossJoin => JoinType::Cross,
            _ => JoinType::Inner, // Default fallback
        }
    }

    fn format_plan(&self, plan: &LogicalPlan, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);
        match plan {
            LogicalPlan::TableScan { table_name, alias, projected_schema } => {
                let alias_str = alias.as_ref()
                    .map(|a| format!(" AS {}", a))
                    .unwrap_or_default();
                format!("{}TableScan: {}{} projection=[{}]\n", 
                       indent_str, table_name, alias_str, projected_schema.join(", "))
            }
            LogicalPlan::Projection { expressions, input } => {
                let expr_strs: Vec<String> = expressions.iter()
                    .map(|e| format!("{:?}", e))
                    .collect();
                format!("{}Projection: [{}]\n{}", 
                       indent_str, expr_strs.join(", "), 
                       self.format_plan(input, indent + 1))
            }
            LogicalPlan::Selection { predicate, input } => {
                format!("{}Selection: {:?}\n{}", 
                       indent_str, predicate,
                       self.format_plan(input, indent + 1))
            }
            LogicalPlan::Join { left, right, join_type, join_constraint } => {
                let constraint_str = join_constraint.as_ref()
                    .map(|c| format!(" ON {:?}", c))
                    .unwrap_or_default();
                format!("{}Join: {:?}{}\n{}{}",
                       indent_str, join_type, constraint_str,
                       self.format_plan(left, indent + 1),
                       self.format_plan(right, indent + 1))
            }
        }
    }

    fn estimate_cost(&self, plan: &LogicalPlan) -> u64 {
        match plan {
            LogicalPlan::TableScan { .. } => 100, // Base scan cost
            LogicalPlan::Projection { input, .. } => 10 + self.estimate_cost(input),
            LogicalPlan::Selection { input, .. } => 50 + self.estimate_cost(input),
            LogicalPlan::Join { left, right, .. } => {
                1000 + self.estimate_cost(left) + self.estimate_cost(right)
            }
        }
    }
}

// Example usage and testing
#[cfg(test)]
mod tests {
    use super::*;
    use sqlparser::dialect::GenericDialect;

    #[test]
    fn test_simple_select() {
        let dialect = Box::new(GenericDialect {});
        let ctx = ExecutionContext::new(dialect);
        
        let sql = "SELECT id, name FROM users";
        println!("{}", ctx.explain(sql));
    }

    #[test]
    fn test_select_with_where() {
        let dialect = Box::new(GenericDialect {});
        let ctx = ExecutionContext::new(dialect);
        
        let sql = "SELECT id, name FROM users WHERE id > 100";
        println!("{}", ctx.explain(sql));
    }

    #[test]
    fn test_join_query() {
        let dialect = Box::new(GenericDialect {});
        let ctx = ExecutionContext::new(dialect);
        
        let sql = "SELECT u.name, o.amount FROM users u INNER JOIN orders o ON u.id = o.user_id";
        println!("{}", ctx.explain(sql));
    }
}

impl fmt::Display for LogicalPlan {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}